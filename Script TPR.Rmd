---
title: "Trabajo Práctico Final - Estadística Actuarial (751-1)"
author:
- Zajdenberg, Dana Rebeca (892.786)
- Barrales Agosti, Julián Guido (889.901)
- Cohen Falah, Iván Nahuel (890.693)
- Lopatka, Lucas Eitán (889.524)
- Ignacio Borovsky (891.119)
html_document: default
output:
  pdf_document: default
  html_document: default
indent: true
---
  
# Introducción  
\  
\  
\ En el presente trabajo se analizarán dos series temporales correspondientes a dos activos financieros distintos, otorgadas por el cuerpo docente. A lo largo del mismo se empleará la metodología de Box-Jenkins, utilizando los conceptos vistos en clase y el programa R-Studio.

```{r, message=FALSE}
library(moments)
library(tseries)
library(urca)
library(forecast)
library(nortest)
```

```{r, echo=FALSE}
Serie1 <- read.csv2("/Users/iborovsky/Desktop/TPR/Grupo 1 - activo financiero.csv")

SerieA<-ts(Serie1[,1])

minimo<-c(min(SerieA))
maximo<-c(max(SerieA))
percentil1<-c(quantile(SerieA,0.25))
mediana<-c(median(SerieA))
percentil3<-c(quantile(SerieA,0.75))
asimetria<-c(skewness(SerieA))
kurtosis<-c(kurtosis(SerieA))
promedio<-c(mean(SerieA))
varianza<-c(var(SerieA))
desvio<-c(sqrt(var(SerieA)))


Analisis_Descriptivo<-c(minimo,maximo,percentil1,mediana,percentil3,asimetria,kurtosis, promedio, varianza, desvio)
nombres<-c("Minimo","Maximo","Percentil 0.25","Mediana","Percentil 0.75","Coef Asimetria","Coef Curtosis", "Promedio", "Varianza", "Desvio")
names(Analisis_Descriptivo)<-nombres

knitr::kable(Analisis_Descriptivo,align="l")

```

###Fase de identificación

\ Se grafica la serie para una primera impresión
  
```{r,echo=FALSE,fig.height=5,fig.width=8}
plot(SerieA)
boxplot(SerieA, main= "Grafico de BoxPlot", col = "red", horizontal = T)
```

\ El gráfico permite observar una reversion a la media (posiblemente cero). Se ve que ocurre con la FAC y FACP estimada,

```{r,echo=FALSE,fig.height=2.5,fig.width=8}
par(mfrow=c(1,3))
acf(SerieA,main="FAS Serie A",type="covariance", col = c("blue", "orange"))
acf(SerieA,main="FAC Serie A", col = c("blue", "orange"))
pacf(SerieA,main="FACP Serie A", col = c("blue", "orange"))
```

\  El grafico de la FAC muestra un decrecimiento sinusoidal. Con el objetivo de determinar la existencia o no de raíces unitarias se efectúa los tests de Dickey-Fuller.

```{r, echo=FALSE}
trend.df<-ur.df(SerieA,type="trend",lags=4)
drift.df<-ur.df(SerieA,type="drift",lags=4)
none.df<-ur.df(SerieA,type="none",lags=4)
```

\ Los valores de Tau empíricos para cada modelo son:  

```{r, echo=FALSE}
t_empiricos<-c(none.df@teststat,drift.df@teststat[1,1],trend.df@teststat[1,1])
names(t_empiricos)<-c("None","Con Drift","Con Trend")

knitr::kable(t_empiricos)
```

\ Y los respectivos valores criticos de Tau son

```{r, echo=FALSE}  
a<-c(none.df@cval[1,1:3])
b<-c(drift.df@cval[1,1:3])
c<-c(trend.df@cval[1,1:3])
tau_crit<-rbind(a,b,c)
rownames(tau_crit)<-c("None","Con Drift","Con Trend")

knitr::kable(tau_crit)
```

\ Por lo tanto se puede afirmar con un nivel de significatividad aproximado a 5% que la serie es no estacionaria para todos los modelos.

##Fase de estimacion

\ A continuacion, se evaluaron todas las posibles combinaciones de modelos ARIMA (p,d,q) con p, d y q entre cero y tres con el fin de seleccionar aquel que mejor ajusta en base a los criterios de informacion vistos en clase.

```{r, echo=FALSE, warning=FALSE}
serieA = ts(Serie1[,1])

coefs = c(0,1,2,3)

rowNames = c()

aicArraySerieA = c()
bicArraySerieA = c()

for(p in coefs){
  for(d in coefs){
    for(q in coefs){
      name = sprintf("ARIMA(%d, %d, %d)", p,d,q)
      
      rowNames = c(rowNames, name)
      
      
      tryCatch(
        {
          newModelSerieA = arima(serieA, c(p,d,q), method="ML")
        },
        error=function(cond) {
          message(cond)
          
          newModelSerieA = arima(serieA, c(p,d,q))
        },
        finally = function(a){
        }
      )
      aicArraySerieA = c(aicArraySerieA, newModelSerieA$aic)
      bicArraySerieA = c(bicArraySerieA, BIC(newModelSerieA))
      
    }
  }
}

serieAInfo = data.frame(AIC=aicArraySerieA, BIC=bicArraySerieA, row.names=NULL)

#Tabla de AIC Y BIC para la serie A
rownames(serieAInfo) = rowNames

minAICserieA = min(serieAInfo$AIC)
minBICserieA = min(serieAInfo$BIC)
nameMinAICserieA = rowNames[which(serieAInfo$AIC==min(serieAInfo$AIC))]
nameMinBICserieA = rowNames[which(serieAInfo$BIC==min(serieAInfo$BIC))]

sprintf("Para la serie A, el menor AIC fue de %s para el modelo %s", minAICserieA, nameMinAICserieA)
sprintf("Para la serie A, el menor BIC fue de %s para el modelo %s", minBICserieA, nameMinBICserieA)

```

\ El modelo que mejor se ajusta segun el criterio BIC es un ARIMA (2,1,1)

```{r}
ModeloA<-arima(SerieA, order=c(2,1,1))
```

$$y_t=-1.2741y_{t-1}-0.7230y_{t-1}+0.6280\epsilon_{t-1}$$
##Fase de validación

\ Se demuestra primero que los coeficientes del modelo estimado son significativos. Para esto es utilizada una función que devuelve un mensaje

```{r}
TestT<-function(modelo){
  for(i in 1:length(modelo$coef)) {
      a=abs(modelo$coef[i]/sqrt(modelo$var.coef[i,i]))
      if(a>=2) {
        print(paste("El coeficiente",names(modelo$coef[i]),"es un parametro significativo"))
      } else {
        paste(print("no es significativo"))
      }
  }
}
```

\ Se ingresa el modelo estimado como input y el codigo devuelve

```{r}
TestT(ModeloA)
```

\ El siguiente paso es que el modelo cumpla con las condiciones de estacionariedad e invertibilidad.

```{r, echo=FALSE}
plot(ModeloA)
```

\ Las raices caen dentro del circulo unidad  
\  
\ Ahora se analiza la normalidad de los residuos. Para ello se realiza un gráfico de *qqnorm* que compara los cuantiles teóricos de la distribución normal con los de los residuos de la serie.

```{r}
qqnorm(ModeloA$residuals)
qqline(ModeloA$residuals)
```

\ Para complementar el **analisis de normalidad** es realizado un test de Jarque Bera

```{r}
jarque.bera.test(ModeloA$residuals)
```

\  Como el *p-value* es 0.6567 y es mayor a un $\alpha$ de 0.1 no rechaza la hipotesis nula de normalidad de los reisudos.
\  
\ Por ultimo, la **incorrelacion de los residuos** es analizada. Se ejecuta el test de Ljung-Box y se obtiene,

```{r}
Box.test(ModeloA$residuals,lag=5,type ="Ljung-Box",fitdf = 3)
Box.test(ModeloA$residuals,lag=7,type ="Ljung-Box",fitdf = 3)
Box.test(ModeloA$residuals,lag=9,type ="Ljung-Box",fitdf = 3)
```

\ Entonces, con un $\alpha$ de 0.1, se puede afirmar que los residuos no estan correlacionados para valores propios desfasados en el dominio del tiempo.

## Fase de Predicción

\ La predicción finalmente para un horizonte de diez periodos y con un nivel de confianza al 95% es,

```{r}
par(mfrow=c(2,2))
plot(forecast(ModeloA, 1,level=95), main="Prediccion 1 periodo")
plot(forecast(ModeloA, 2,level=95), main="Prediccion 2 periodos")
plot(forecast(ModeloA, 3,level=95), main="Prediccion 3 periodos")
plot(forecast(ModeloA, 20,level=95), main="Prediccion 20 periodos")
```

\ Los valores del gráfico son representados en el siguiente cuadro. Se calcularon los intervalos para el 94%, 95% y 99% de confianza.

```{r, echo=FALSE}
argumentos <- c(1,2,3, 20)

x<-cbind(
  forecast(ModeloA, 20, level=0.99)$lower[argumentos],  
  forecast(ModeloA, 20, level=0.95)$lower[argumentos],
  forecast(ModeloA, 20, level=0.94)$lower[argumentos],
  forecast(ModeloA, 20, level=0.94)$mean[argumentos],
  forecast(ModeloA, 20, level=0.94)$upper[argumentos],
  forecast(ModeloA, 20, level=0.95)$upper[argumentos],
  forecast(ModeloA, 20, level=0.99)$upper[argumentos]
)
colnames(x)<-c("Limite inferior 0.99","Limite inferior 0.95","Limite inferior 0.94","Prediccion","Limite sueprior 0.94","Limite superior 0.95","Limite superior 0.99")

knitr::kable(x,
   align="l",
   caption="Intervalos de confianza para el Modelo A"
)
```

\ Efectuado el analisis, se procede a exportar los datos en formato CSV

```{r, eval=FALSE}

Serie_estimadaA<-c(SerieA,forecast(ModeloA, 20, level=95)$mean)
data.frame(x)
write.csv(Serie_estimadaA,"/Users/iborovsky/Desktop/TPR/SerieEstimadaA.csv")
```


## Análisis de la serie numero dos

\ Ahora se repite el análisis para la siguiente serie. En principio, se describe la serie.

```{r, echo=FALSE}
SerieB<-ts(Serie1[,2])

minimo<-c(min(SerieB))
maximo<-c(max(SerieB))
percentil1<-c(quantile(SerieB,0.25))
mediana<-c(median(SerieB))
percentil3<-c(quantile(SerieB,0.75))
asimetria<-c(skewness(SerieB))
kurtosis<-c(kurtosis(SerieB))
promedio<-c(mean(SerieB))
varianza<-c(var(SerieB))
desvio<-c(sqrt(var(SerieB)))

Analisis_Descriptivo<-c(minimo,maximo,percentil1,mediana,percentil3,asimetria,kurtosis, promedio, varianza, desvio)
nombres<-c("Minimo","Maximo","Percentil 0.25","Mediana","Percentil 0.75","Coef Asimetria","Coef Curtosis", "Promedio", "Varianza", "Desvio")
names(Analisis_Descriptivo)<-nombres

knitr::kable(Analisis_Descriptivo,align="l")

```
###Fase de identificacion

\ Se observa el gráfico de la serie
  
```{r,echo=FALSE,fig.height=5,fig.width=8}
plot(SerieB)
boxplot(SerieB, main= "Grafico de BoxPlot", col = "red", horizontal = T)
```

\ El mismo no permite ver en principio la reversion a la media. Continúa con la FAC y FACP estimada,

```{r,echo=FALSE,fig.height=2.5,fig.width=8}
par(mfrow=c(1,3))
acf(SerieB,main="FAS Serie B",type="covariance")
acf(SerieB,main="FAC Serie B")
pacf(SerieB,main="FACP Serie B")
```

\ A través de la FACP se verifica que decrece lentamente de manera sinusoidal. Por otro lado, la FAC se anula al primer rezago. Los gráficos proponen la posibilidad de que sea un proceso de medias moviles no estacionaro. Para confirmar estas intuiciones son realizados los correspondientes tests de Dickey-Füller

```{r, echo=FALSE}
trend.df<-ur.df(SerieB,type="trend",lags=4)
drift.df<-ur.df(SerieB,type="drift",lags=4)
none.df<-ur.df(SerieB,type="none",lags=4)
```

\ Los valores de Tau empíricos para cada modelo son:  

```{r, echo=FALSE}
t_empiricos<-c(none.df@teststat,drift.df@teststat[1,1],trend.df@teststat[1,1])
names(t_empiricos)<-c("None","Con Drift","Con Trend")

knitr::kable(t_empiricos)
```

\ Y los respectivos valores criticos de Tau son

```{r, echo=FALSE}  
a<-c(none.df@cval[1,1:3])
b<-c(drift.df@cval[1,1:3])
c<-c(trend.df@cval[1,1:3])
tau_crit<-rbind(a,b,c)
rownames(tau_crit)<-c("None","Con Drift","Con Trend")

knitr::kable(tau_crit)
```

\  Existe evidencia suficiente para que sea razonable no rechazar la hipótesis nula de estacionariedad para modelos *none* y *drift*. Sin embargo, se rechaza para un modelo con tendencia. (Supone un $\alpha$ del 5%)    
  
###Fase de estimacion

\ Se reutiliza el codigo para la seleccion del modelo anterior. El que mejor se ajusta segun BIC es el modelo ARIMA (0,1,2)

```{r, echo=FALSE, warning=FALSE}

serieB = ts(Serie1[, 2])

coefs = c(0,1,2,3,4)

rowNames = c()

aicArraySerieB = c()
bicArraySerieB = c()

for(p in coefs){
  for(d in coefs){
    for(q in coefs){
      name = sprintf("ARIMA(%d, %d, %d)", p,d,q)
      
      rowNames = c(rowNames, name)
      
      
      tryCatch(
        {
          newModelSerieB = arima(SerieB, c(p,d,q), method="ML")
        },
        error=function(cond) {
          message(cond)
          
          newModelSerieB = arima(SerieB, c(p,d,q))
        },
        finally = function(a){
        }
      )
      aicArraySerieB = c(aicArraySerieB, newModelSerieB$aic)
      bicArraySerieB = c(bicArraySerieB, BIC(newModelSerieB))
      
    }
  }
}

serieBInfo = data.frame(AIC=aicArraySerieB, BIC=bicArraySerieB, row.names=NULL)

#Tabla de AIC Y BIC para la serie B
rownames(serieBInfo) = rowNames

minAICserieB = min(serieBInfo$AIC)
minBICserieB = min(serieBInfo$BIC)
nameMinAICserieB = rowNames[which(serieBInfo$AIC==min(serieBInfo$AIC))]
nameMinBICserieB = rowNames[which(serieBInfo$BIC==min(serieBInfo$BIC))]

sprintf("Para la serie B, el menor AIC fue de %s para el modelo %s", minAICserieB, nameMinAICserieB)
sprintf("Para la serie B, el menor BIC fue de %s para el modelo %s", minBICserieB, nameMinBICserieB)
  
```

\  Entonces el modelo apropiado es,

```{r}
ModeloB<-arima(SerieB, order=c(0,1,2))
```

$$\hat{y_t}=1.2202\epsilon_{t-1}-0.3677\epsilon_{t-2}$$

##Fase de validacion

\ Se verifica que los coeficientes del modelo estimado son significativos, 

```{r}
TestT(ModeloB)
```

\  la condicion de invertibilidad,

```{r, echo=FALSE}
plot(ModeloB)
```

\ Cae dentro del círculo unidad ambas raíces

\ Ahora se analiza la normalidad de los residuos. Se repite el gráfico de *qqnorm*

```{r, echo =FALSE}
qqnorm(ModeloB$residuals)
qqline(ModeloB$residuals)
```

\ Se observa que los cuantiles teóricos coinciden con los cuantiles de los residuos.

\ Para complementar, el **analisis de normalidad** se utiliza el test de Jarque Bera

```{r, echo =FALSE}
jarque.bera.test(ModeloB$residuals)
```

\ Como el *pvalue* es cercano a uno, se tiene cierta certeza de que los residuos del modelo estimado siguen una distribución normal.

\ Respecto de la **incorrelacion de los residuos**. Se utiliza el test de Ljung-Box para distintos rezagos.

```{r, echo =FALSE}
Box.test(ModeloB$residuals,lag=4,type ="Ljung-Box",fitdf = 3)
Box.test(ModeloB$residuals,lag=6,type ="Ljung-Box",fitdf = 3)
Box.test(ModeloB$residuals,lag=8,type ="Ljung-Box",fitdf = 3)
```

\ Los test de incorrelación para rezagos de 4, 6, y 8 arrojan respectivamente valores *p* de 0.91, 0.94 y 0.899. Por lo tanto, hay suficiente evidencia de que los residuos del modelo estan incorrelacionados para valores defasados.

##Fase de predicción

\ Como se remarcó anteriormente, no es correcto predecir a partir de un modelo de medias móviles. Sin embargo, se ejecuta el código para observar los resultados.

```{r, echo =FALSE}
par(mfrow=c(2,2))
plot(forecast(ModeloB, 1,level=95), main="Prediccion 1 periodo")
plot(forecast(ModeloB, 2,level=95), main="Prediccion 2 periodos")
plot(forecast(ModeloB, 3,level=95), main="Prediccion 3 periodos")
plot(forecast(ModeloB, 20,level=95), main="Prediccion 20 periodos")
```

\ Se vuelcan los resultados en la tabla,

```{r, echo=FALSE}

argumentos <- c(1,2,3, 20)

x<-cbind(
  forecast(ModeloB, 20, level=0.99)$lower[argumentos],  
  forecast(ModeloB, 20, level=0.95)$lower[argumentos],
  forecast(ModeloB, 20, level=0.94)$lower[argumentos],
  forecast(ModeloB, 20, level=0.94)$mean[argumentos],
  forecast(ModeloB, 20, level=0.94)$upper[argumentos],
  forecast(ModeloB, 20, level=0.95)$upper[argumentos],
  forecast(ModeloB, 20, level=0.99)$upper[argumentos]
)
colnames(x)<-c("Limite inferior 0.99","Limite inferior 0.95","Limite inferior 0.94","Prediccion","Limite sueprior 0.94","Limite superior 0.95","Limite superior 0.99")

knitr::kable(x,
             align="l",
             caption="Intervalos de confianza para el Modelo B"
)
```

\ Efectuado el análisis, los datos son exportados en formato CSV.

```{r, eval=FALSE}

Serie_extendidaB<-c(SerieB,forecast(ModeloB, 20, level=95)$mean)
write.csv(Serie_extendidaB,"/Users/iborovsky/Desktop/TPR/SerieEstimadaB.csv")

```


***

# Conclusiones

\  Se realizaron dos análisis, uno por cada serie.  
\    
\  La primer serie resultó no ser estacionaria. Se modelizó la misma para un ARIMA(2,1,1) donde se verificaron todos los supuestos vistos en el curso y finalmente concluyó con una predicción para diez períodos.  
\  
\  En cuanto a la segunda serie, tampoco pudo demostrarse su estacionariedad. El modelo indicado fue un ARIMA (0,1,2) que cumplió con todos los supuestos, tanto los de invertibilidad y como aquellos correspondientes a los residuos. Su predicción arrojó un resultado ambiguo por los motivos expresados con anterioridad.  

# Futuras investigaciones y limitaciones

\  El análisis efectuado se limitó a los modelos de la familia ARIMA. No se tomó en cuenta la posibilidad de realizar una diferencación fraccionaria, ni modelizar la serie en otras familias de modelos para series de tiempo.    
\  Por otra parte, se utilizaron los tests vistos y estudiados en la materia *751-Estadistica Actuarial*. Como se utilizó Dickey-Fuller para el análisis de raíces unitaras se pudieron haber utilizado otros tests como el de KPSS o Phillips-Perron.

***

# Bibliografía

* *Analisis de series temporales: modelos ARIMA* - Ezequiel Uriel Jimenez; Valencia, España, 1985.
* *"Time Series Analysis. Forecasting and Control. Fourth edition"* - George E. P. Box, Gwilym M. Jenkins, Gregory C. Reinsel.
* *Acerca de la probabilidad* - Alberto H Landro, 2010.

***
